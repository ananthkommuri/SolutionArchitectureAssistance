import type { ArchitectureRecommendation } from "@shared/schema";

export function generateCloudFormationTemplate(architecture: ArchitectureRecommendation): string {
  const template = {
    AWSTemplateFormatVersion: "2010-09-09",
    Description: "AWS Architecture generated by AI Assistant",
    Parameters: {
      Environment: {
        Type: "String",
        Default: "production",
        AllowedValues: ["development", "staging", "production"],
        Description: "Environment name"
      },
      KeyPairName: {
        Type: "AWS::EC2::KeyPair::KeyName",
        Description: "EC2 Key Pair for SSH access"
      }
    },
    Resources: {} as Record<string, any>,
    Outputs: {} as Record<string, any>
  };

  // Generate VPC and networking resources
  template.Resources.VPC = {
    Type: "AWS::EC2::VPC",
    Properties: {
      CidrBlock: "10.0.0.0/16",
      EnableDnsHostnames: true,
      EnableDnsSupport: true,
      Tags: [
        { Key: "Name", Value: { Ref: "Environment" } }
      ]
    }
  };

  template.Resources.InternetGateway = {
    Type: "AWS::EC2::InternetGateway",
    Properties: {
      Tags: [{ Key: "Name", Value: { "Fn::Sub": "${Environment}-IGW" } }]
    }
  };

  template.Resources.VPCGatewayAttachment = {
    Type: "AWS::EC2::VPCGatewayAttachment",
    Properties: {
      VpcId: { Ref: "VPC" },
      InternetGatewayId: { Ref: "InternetGateway" }
    }
  };

  // Public subnets
  template.Resources.PublicSubnet1 = {
    Type: "AWS::EC2::Subnet",
    Properties: {
      VpcId: { Ref: "VPC" },
      CidrBlock: "10.0.1.0/24",
      AvailabilityZone: { "Fn::Select": [0, { "Fn::GetAZs": "" }] },
      MapPublicIpOnLaunch: true,
      Tags: [{ Key: "Name", Value: { "Fn::Sub": "${Environment}-Public-Subnet-1" } }]
    }
  };

  template.Resources.PublicSubnet2 = {
    Type: "AWS::EC2::Subnet",
    Properties: {
      VpcId: { Ref: "VPC" },
      CidrBlock: "10.0.2.0/24",
      AvailabilityZone: { "Fn::Select": [1, { "Fn::GetAZs": "" }] },
      MapPublicIpOnLaunch: true,
      Tags: [{ Key: "Name", Value: { "Fn::Sub": "${Environment}-Public-Subnet-2" } }]
    }
  };

  // Private subnets
  template.Resources.PrivateSubnet1 = {
    Type: "AWS::EC2::Subnet",
    Properties: {
      VpcId: { Ref: "VPC" },
      CidrBlock: "10.0.3.0/24",
      AvailabilityZone: { "Fn::Select": [0, { "Fn::GetAZs": "" }] },
      Tags: [{ Key: "Name", Value: { "Fn::Sub": "${Environment}-Private-Subnet-1" } }]
    }
  };

  template.Resources.PrivateSubnet2 = {
    Type: "AWS::EC2::Subnet",
    Properties: {
      VpcId: { Ref: "VPC" },
      CidrBlock: "10.0.4.0/24",
      AvailabilityZone: { "Fn::Select": [1, { "Fn::GetAZs": "" }] },
      Tags: [{ Key: "Name", Value: { "Fn::Sub": "${Environment}-Private-Subnet-2" } }]
    }
  };

  // Route tables
  template.Resources.PublicRouteTable = {
    Type: "AWS::EC2::RouteTable",
    Properties: {
      VpcId: { Ref: "VPC" },
      Tags: [{ Key: "Name", Value: { "Fn::Sub": "${Environment}-Public-RT" } }]
    }
  };

  template.Resources.PublicRoute = {
    Type: "AWS::EC2::Route",
    DependsOn: "VPCGatewayAttachment",
    Properties: {
      RouteTableId: { Ref: "PublicRouteTable" },
      DestinationCidrBlock: "0.0.0.0/0",
      GatewayId: { Ref: "InternetGateway" }
    }
  };

  // Generate resources based on architecture services
  architecture.services.forEach((service, index) => {
    const resourceName = service.name.replace(/[^a-zA-Z0-9]/g, '') + index;

    switch (service.type.toLowerCase()) {
      case 'compute':
        if (service.name.includes('EC2') || service.name.includes('Instance')) {
          // Security Group for EC2
          template.Resources[`${resourceName}SecurityGroup`] = {
            Type: "AWS::EC2::SecurityGroup",
            Properties: {
              GroupDescription: `Security group for ${service.name}`,
              VpcId: { Ref: "VPC" },
              SecurityGroupIngress: [
                {
                  IpProtocol: "tcp",
                  FromPort: 80,
                  ToPort: 80,
                  CidrIp: "0.0.0.0/0"
                },
                {
                  IpProtocol: "tcp",
                  FromPort: 443,
                  ToPort: 443,
                  CidrIp: "0.0.0.0/0"
                }
              ],
              Tags: [{ Key: "Name", Value: { "Fn::Sub": `\${Environment}-${service.name}-SG` } }]
            }
          };

          // Launch Template
          template.Resources[`${resourceName}LaunchTemplate`] = {
            Type: "AWS::EC2::LaunchTemplate",
            Properties: {
              LaunchTemplateName: { "Fn::Sub": `\${Environment}-${service.name}-LT` },
              LaunchTemplateData: {
                ImageId: "ami-0abcdef1234567890", // Amazon Linux 2
                InstanceType: service.configuration?.instanceType || "t3.medium",
                KeyName: { Ref: "KeyPairName" },
                SecurityGroupIds: [{ Ref: `${resourceName}SecurityGroup` }],
                UserData: {
                  "Fn::Base64": {
                    "Fn::Sub": `#!/bin/bash
yum update -y
yum install -y httpd
systemctl start httpd
systemctl enable httpd
echo "<h1>Hello from \${Environment}</h1>" > /var/www/html/index.html`
                  }
                }
              }
            }
          };

          // Auto Scaling Group
          template.Resources[`${resourceName}AutoScalingGroup`] = {
            Type: "AWS::AutoScaling::AutoScalingGroup",
            Properties: {
              VPCZoneIdentifier: [
                { Ref: "PrivateSubnet1" },
                { Ref: "PrivateSubnet2" }
              ],
              LaunchTemplate: {
                LaunchTemplateId: { Ref: `${resourceName}LaunchTemplate` },
                Version: { "Fn::GetAtt": [`${resourceName}LaunchTemplate`, "LatestVersionNumber"] }
              },
              MinSize: "1",
              MaxSize: "10",
              DesiredCapacity: "2",
              TargetGroupARNs: [{ Ref: `${resourceName}TargetGroup` }],
              Tags: [
                {
                  Key: "Name",
                  Value: { "Fn::Sub": `\${Environment}-${service.name}-ASG` },
                  PropagateAtLaunch: true
                }
              ]
            }
          };
        }
        break;

      case 'database':
        if (service.name.includes('RDS')) {
          // DB Subnet Group
          template.Resources[`${resourceName}SubnetGroup`] = {
            Type: "AWS::RDS::DBSubnetGroup",
            Properties: {
              DBSubnetGroupDescription: `Subnet group for ${service.name}`,
              SubnetIds: [
                { Ref: "PrivateSubnet1" },
                { Ref: "PrivateSubnet2" }
              ],
              Tags: [{ Key: "Name", Value: { "Fn::Sub": `\${Environment}-${service.name}-SubnetGroup` } }]
            }
          };

          // Security Group for RDS
          template.Resources[`${resourceName}SecurityGroup`] = {
            Type: "AWS::EC2::SecurityGroup",
            Properties: {
              GroupDescription: `Security group for ${service.name}`,
              VpcId: { Ref: "VPC" },
              SecurityGroupIngress: [
                {
                  IpProtocol: "tcp",
                  FromPort: 5432,
                  ToPort: 5432,
                  SourceSecurityGroupId: { Ref: "EC2SecurityGroup" }
                }
              ]
            }
          };

          // RDS Instance
          template.Resources[resourceName] = {
            Type: "AWS::RDS::DBInstance",
            Properties: {
              DBInstanceIdentifier: { "Fn::Sub": `\${Environment}-${service.name.toLowerCase()}` },
              DBInstanceClass: service.configuration?.instanceType || "db.t3.medium",
              Engine: "postgres",
              EngineVersion: "13.7",
              AllocatedStorage: "100",
              StorageType: "gp2",
              MasterUsername: "dbadmin",
              MasterUserPassword: "ChangeMe123!",
              VPCSecurityGroups: [{ Ref: `${resourceName}SecurityGroup` }],
              DBSubnetGroupName: { Ref: `${resourceName}SubnetGroup` },
              BackupRetentionPeriod: 7,
              MultiAZ: service.configuration?.multiAZ || false,
              Tags: [{ Key: "Name", Value: { "Fn::Sub": `\${Environment}-${service.name}` } }]
            }
          };
        }
        break;

      case 'networking':
        if (service.name.includes('Load Balancer') || service.name.includes('ALB')) {
          // Target Group
          template.Resources[`${resourceName}TargetGroup`] = {
            Type: "AWS::ElasticLoadBalancingV2::TargetGroup",
            Properties: {
              Name: { "Fn::Sub": `\${Environment}-${service.name}-TG` },
              Port: 80,
              Protocol: "HTTP",
              VpcId: { Ref: "VPC" },
              HealthCheckPath: "/",
              HealthCheckProtocol: "HTTP",
              HealthCheckIntervalSeconds: 30,
              HealthyThresholdCount: 2,
              UnhealthyThresholdCount: 5
            }
          };

          // Application Load Balancer
          template.Resources[resourceName] = {
            Type: "AWS::ElasticLoadBalancingV2::LoadBalancer",
            Properties: {
              Name: { "Fn::Sub": `\${Environment}-${service.name}` },
              Scheme: "internet-facing",
              Type: "application",
              Subnets: [
                { Ref: "PublicSubnet1" },
                { Ref: "PublicSubnet2" }
              ],
              SecurityGroups: [{ Ref: "ALBSecurityGroup" }]
            }
          };

          // Listener
          template.Resources[`${resourceName}Listener`] = {
            Type: "AWS::ElasticLoadBalancingV2::Listener",
            Properties: {
              DefaultActions: [{
                Type: "forward",
                TargetGroupArn: { Ref: `${resourceName}TargetGroup` }
              }],
              LoadBalancerArn: { Ref: resourceName },
              Port: 80,
              Protocol: "HTTP"
            }
          };
        }
        break;
    }
  });

  // Add outputs
  template.Outputs = {
    VPCId: {
      Description: "VPC ID",
      Value: { Ref: "VPC" },
      Export: { Name: { "Fn::Sub": "${Environment}-VPC-ID" } }
    }
  };

  return JSON.stringify(template, null, 2);
}

export function generateTerraformTemplate(architecture: ArchitectureRecommendation): string {
  // Basic Terraform template - could be expanded
  return `# Terraform configuration for AWS architecture
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

provider "aws" {
  region = var.aws_region
}

variable "aws_region" {
  description = "AWS region"
  type        = string
  default     = "us-east-1"
}

variable "environment" {
  description = "Environment name"
  type        = string
  default     = "production"
}

# VPC
resource "aws_vpc" "main" {
  cidr_block           = "10.0.0.0/16"
  enable_dns_hostnames = true
  enable_dns_support   = true

  tags = {
    Name = var.environment
  }
}

# Internet Gateway
resource "aws_internet_gateway" "main" {
  vpc_id = aws_vpc.main.id

  tags = {
    Name = "\${var.environment}-igw"
  }
}

# Public Subnets
resource "aws_subnet" "public_1" {
  vpc_id                  = aws_vpc.main.id
  cidr_block              = "10.0.1.0/24"
  availability_zone       = data.aws_availability_zones.available.names[0]
  map_public_ip_on_launch = true

  tags = {
    Name = "\${var.environment}-public-subnet-1"
  }
}

resource "aws_subnet" "public_2" {
  vpc_id                  = aws_vpc.main.id
  cidr_block              = "10.0.2.0/24"
  availability_zone       = data.aws_availability_zones.available.names[1]
  map_public_ip_on_launch = true

  tags = {
    Name = "\${var.environment}-public-subnet-2"
  }
}

data "aws_availability_zones" "available" {
  state = "available"
}

output "vpc_id" {
  description = "ID of the VPC"
  value       = aws_vpc.main.id
}`;
}
